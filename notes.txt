npm i express@4.21.2 mongoose@8.10.1 jsonwebtoken@9.0.2 bcryptjs@2.4.3
npm i express@4.21.2 mongoose@8.10.1 jsonwebtoken@9.0.2 bcryptjs@2.4.3


set github account in vscode
git config user.name "Your Name"
git config user.email "your@email.com"

ğŸ§© What --prefix means

The --prefix <folder> flag tells npm:
ğŸ‘‰ â€œRun this command as if you were inside that folder.â€

So instead of cd backend && npm install, you can stay in the root and just do it in one line.

âš›ï¸ npm run build --prefix frontend
â†’ runs the build script defined inside frontend/package.json (Vite build).

app.use(express.static(...))

ğŸ“‚ express.static is middleware that tells Express:
ğŸ‘‰ â€œWhenever someone requests a file (like /index.html or /style.css), go look inside this folder and serve it.â€

path.join(__dirname, '../frontend/dist')

ğŸ›£ Builds the full file path to your frontend build folder:

__dirname â†’ current backend folder.

../frontend/dist â†’ steps one level up, then into frontend/dist.

ğŸ¬ Example

Say your project is:
backend/server.js
frontend/dist/index.html
frontend/dist/assets/index.js

When a user hits / in the browser:

ğŸ” Express looks in frontend/dist.

Finds index.html.

Sends it back â†’ React app loads.

When a user hits /about:

React handles it in client-side routing (after Express serves index.html).

=>>>>>>>>>>>>>>>>>>>>>>>
The protectRoute middleware
export const protectRoute = async (req, res, next) => {
  const token = req.cookies.jwt;          // Get token from cookies
  const decoded = jwt.verify(token, ENV.JWT_SECRET);  
  const user = await User.findById(decoded.userId);  // Fetch user from DB
  req.user = user;                         // âš¡ Save user info in request
  next();                                  // Move to next middleware/route
};



Example Route Using req.user
app.get('/api/profile', protectRoute, (req, res) => {
  // Because protectRoute ran first, req.user exists
  res.json({
    name: req.user.fullName,
    email: req.user.email,
    profilePic: req.user.profilePic
  });
});

export const getChatPartners = async (req, res) => {
  try {
    const loggedInUserId = req.user._id;
    const messages = await Message.find({
      $or: [{ senderId: loggedInUserId }, { receiverId: loggedInUserId }],
    });
    const chatPartnersIds = messages.map((msg) => [
      ...new Set([
        msg.senderId.toString() === loggedInUserId.toString()
          ? msg.receiverId.toString()
          : msg.senderId.toString(),
      ]),
    ]);
    const chatPartners = await User.find({
      _id: { $in: chatPartnersIds.flat() },
    }).select('-password');
    res.status(200).json(chatPartners);
  } catch (error) {
    res.status(500).json({ message: 'Server error', error });
  }
};

ğŸ” What each line does (with a simple example)

Assume:

Logged-in user id: U1

There are messages in the DB with sender/receiver pairs:

M1: { senderId: 'U1', receiverId: 'U2', text: 'hi' }

M2: { senderId: 'U3', receiverId: 'U1', text: 'hello' }

M3: { senderId: 'U1', receiverId: 'U2', text: 'how are you' }

M4: { senderId: 'U4', receiverId: 'U1', text: 'yo' }

const loggedInUserId = req.user._id;

Takes the authenticated user id from protectRoute.

Example: loggedInUserId = 'U1'.

const messages = await Message.find({ $or: [{ senderId: loggedInUserId }, { receiverId: loggedInUserId }] });

Queries DB for all messages involving U1 either as sender or receiver.

With example data, messages = [M1, M2, M3, M4] (the four objects above).

The weird mapping block:
const chatPartnersIds = messages.map((msg) => [
  ...new Set([
    msg.senderId.toString() === loggedInUserId.toString()
      ? msg.receiverId.toString()
      : msg.senderId.toString(),
  ]),
]);
For each msg it:

Checks msg.senderId.toString() === loggedInUserId.toString() â€” â€œis the logged-in user the sender?â€

If yes â†’ partner is msg.receiverId, else partner is msg.senderId.

Wraps the single partner id into a new Set([...]) and spreads to an array.

What that actually produces (example):

For M1 (U1 â†’ U2) â†’ partner 'U2' â†’ ['U2']

For M2 (U3 â†’ U1) â†’ partner 'U3' â†’ ['U3']

For M3 (U1 â†’ U2) â†’ partner 'U2' â†’ ['U2']

For M4 (U4 â†’ U1) â†’ partner 'U4' â†’ ['U4']

So chatPartnersIds = [['U2'], ['U3'], ['U2'], ['U4']].

Note: Using new Set per message is pointless because each inner array only contains one element â€” Set does nothing here.

const chatPartners = await User.find({ _id: { $in: chatPartnersIds.flat() } }).select('-password');

chatPartnersIds.flat() flattens [['U2'], ['U3'], ['U2'], ['U4']] â†’ ['U2','U3','U2','U4'].

The DB query { _id: { $in: [...] } } returns users whose _id is in that list. Duplicates in the array are fine â€” Mongo will fetch each user once.

.select('-password') excludes the password field from results.

Final result: array of User documents for U2, U3, U4.

res.status(200).json(chatPartners);

Returns the partners to the client.

5:47:26